use warnings;
use strict;
my $good_data = 
    [
        0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
        0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
    ];

my $chatter_example = 
    [
        0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0,
        0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1,
        1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1,
        0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
    ];


my $real_example = [ 
0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1,
1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 
];
if(1){
print "GOOD-DATA:\n";
handle_scans($good_data);
    print "THEIRS:  0000001111111111100000001111100000000111111111110000000001111111000\n";
    print "\nORIG:    " . join("",@$good_data);
print "\n";
print "CORRUPT-DATA:\n";
handle_scans($chatter_example);
    print "THEIRS:  0000001111111111100000001111100000000111111111110000000001111111000\n";
    print "\nORIG:    " . join("",@$good_data);
}
print "\n\nREAL WORLD\n";
handle_scans($real_example);

print "\n";

sub handle_scans() {
    my $data = shift;
    print "DATA:    " . join("",@$data);
    print "\nOLD:     ";
    my $db = debouncer->new();
    for my $entry (@$data) {
     	debounce_orig( $entry, $db );
    	print  $db->state ;
    }

    print "\nNEW:     ";
    $db = debouncer->new();
    my @counters;
    for my $entry (@$data) {
    	 debounce( $entry, $db );
    	print $db->state ;
        push @counters, $db->counter();
    }
    #print "\n";
    #print "COUNTERS:" . join( "", @counters ) . "\n";

    print "\nOVERSCAN:";
    my $db2 = debouncer->new();
    my @counters2;
    for my $entry (@$data) {
    	 debounce_overscan( $entry, $db2 );
    	print $db2->state ;
        push @counters2, $db2->counter();
    }


   # print "\n";
   # print "COUNTERS:" . join( "", @counters2 ) . "\n";
    print "\n";





}

sub debounce_orig {
    my $sample    = shift;
    my $debouncer = shift;

    my $state_has_changed;
    my $changes;

    # Use xor to detect $changes from last stable state:
    # if a key has changed, it's bit will be 1, otherwise 0
    $state_has_changed = $sample ^ $debouncer->state;

    # Increment counters and reset any unchanged bits:
    # increment bit 1 for all changed keys

    # If the current sample's state does not match the last debounced state
    # and the previous $debouncer state is either 0,0 or 1,1, set db1 to 1.
    $debouncer->db1 = ( ( $debouncer->db1 ) ^ ( $debouncer->db0 ) ) & $state_has_changed;

    # increment bit 0 for all changed keys
    # Set db0 to 1 if it was previously 0 and is now 1?

    $debouncer->db0 = ~( $debouncer->db0 ) & $state_has_changed;

    # Calculate returned change set: if $state_has_changed is still true
    # and the counter has wrapped back to 0, the key is changed.

    $changes =
      ~( ~$state_has_changed | ( $debouncer->db0 ) | ( $debouncer->db1 ) );

  # Update state: in this case use xor to flip any bit that is true in $changes.
    $debouncer->state ^= $changes;

    return $changes;

}

sub debounce {
    my $sample    = shift;
    my $debouncer = shift;

    my $delta;
    my $changes = 0;

    $delta = $sample ^ $debouncer->state;

    if ( $sample ^ 1 ) {
        if ( $debouncer->counter > 0 ) {
            $debouncer->counter = $debouncer->counter - 1;
        }
    }
    else {
        if ( $debouncer->counter < 3 ) {
            $debouncer->counter = $debouncer->counter + 1;
        }
    }
    if ( $delta & 1 ) {
        if ( $debouncer->counter == 0 || $debouncer->counter == 3 ) {
            $changes = 1;
        }
    }

    $debouncer->state ^= $changes;

    return $changes;

}

sub debounce_overscan {
    my $sample    = shift;
    my $debouncer = shift;

    my $delta;
    my $changes = 0;

	my $ciel =8; 
	my $floor = 0;
	my $on_threshold =4;
	my $off_threshold = 2;

    $delta = $sample ^ $debouncer->state;

    if ( $sample ==0 ) {
        if ( $debouncer->counter > $floor ) {
            $debouncer->counter = $debouncer->counter - 1;
        if ( $debouncer->counter == $off_threshold && $delta ) {
            $changes = 1;
    	    $debouncer->state = 0;
    }
        }
    } elsif ($sample ==1)  {
        if ( $debouncer->counter < $ciel ) {
            $debouncer->counter = $debouncer->counter + 1;
        if ( $debouncer->counter == $on_threshold && $delta ) {
            $changes = 1;
    	    $debouncer->state = 1;
        }
        }
    }


    return $changes;

}

package debouncer;

sub new {
    my $class = shift;
    my $self  = {};
    bless $self, $class;
    $self->db0     = 0;
    $self->db1     = 0;
    $self->state   = 0;
    $self->counter = 0;
    return $self;
}

sub db0 : lvalue {
    return shift->{db0};
}

sub db1 : lvalue {
    return shift->{db1};
}

sub state : lvalue {
    return shift->{state};
}

sub counter : lvalue {
    return shift->{counter};
}
